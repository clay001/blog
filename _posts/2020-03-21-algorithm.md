---
layout: post
title: "OS learning"
date: 2020-03-21 01:13:14
image: '/assets/img/'
description: 'Algorithm learning note'
tags:
- algorithm
categories:
- Backend
twitter_text: 'Do you know these?'

---

## Everyday sentence

11-29: I don't like rasins. They used to be fat and jucy, and now they are twisted. They had their lives stolen. They taste sweet, but really they are humiliated grapes.

12-1: We all fear death and question our place in the universe. The artist's job is not to succumb to despair, but to find an antidote for the emptiness of existence.

12-2: You know the only thing that has made the whole thing worthwhile...has been those... few times that I've been able to really, truly connect with another human being.

12-3: We are made of dreams, and dreams are made of us.

12-5: Funny, how just when you think life can't possibly get any worse it suddenly does.

12-6: 美丽的梭罗河/ 我为你歌唱 / 你的光荣历史 / 我永远记在心上 / 旱季来临 / 你轻轻流淌 / 雨季时波涛滚滚 / 你流向远方

## 快速排序和快速选择排序

都是基于分治的思想

快排一般是选左边的数low作为基准数，然后从表的最右边放一个哨兵开始向左搜索，找到第一个小于基准数的记录，并将其的值赋给low，然后从左侧开始向右搜索，找到第一个大于基准数的记录，把其值赋给right，然后再交替搜索，直到指针相遇，把基准数的值赋给这个指针的位置，这样就以pivot为标准完成了一次划分，依次对左右进行递归即可

后来我又看见了一种新的思路去做，该思路是随机选择一个主元，然后把它放在最右边。定义两个指针 i 和 j ，一开始 i = l - 1，j = l。每次移动 j , 如果 j 上的值比主元要大，就 j ++。否则 i +1 ， 交换 i 和 j。 j 移动到 r - 1的时候终止。交换 i + 1和 r 即可完成一次划分

在主sort函数里面把 r <= l 的情况return掉，然后根据partition得到mid，分别对左右两块进行递归

快速选择是为了找到第K大的数的一种更高效的算法，它可以不用保证主元左右两边有序，一次主元划分结束后比较k和主元的位置，有选择地对左边或者右边递归。一般分为select函数，和一个内部的partition函数。partition是一个用于找主元位置的函数，select用二分的思想并进行剪枝，只需要一半的计算量，另外在主元的选择上多了一步随机选择

## BFPRT算法

这是更高级的算法，通过n/mod 5，向下取整分组，每组中五个元素，每个组的中位数可以用插入排序得到。通常被分为partition函数，pivot_median函数，bfprt函数。思想是用组中中位数的中位数作为pivot来划分。经过数学证明在top k问题上有线性的复杂度

## 堆排序

构建大根堆，使得父元素的节点大于等于它的子节点。我们将堆顶最大的元素与末尾元素进行交换，通过调整堆顶元素使得剩下的n - 1个元素仍为大根堆，重复执行以上的操作就可以得到一个有序序列

## 归并排序

二分序列，对左右分别进行排序，然后最后线性归并，用两个指针分别指示两个序列中归并到哪一位了

## 待做的题目

最小窗口子序列，找迷宫中的最小路径

## 卡特兰数

2n个人围城一圈,两两握手,没有交叉，问有多少种方式：第一个人可以和偶数的人握手，h(n) 定义为2*n个人的方式次数，h(0) = 1, h(1) = 1, h(n) = h(0) * h(n -1) + .... h(n-1)*h(0)

C(n,2n)/(n+1)  = C(n,2n) - C(n+1,2n) = (4n-2)*h(n-1)/(n+1)

= (2n!) / (n! \* n!) / (n + 1)

一堆数入出栈序列的组合数，小兔的棋盘（从00到nn不越过对角线的走法），可以转换成序列任务。组合数把入栈看作1出栈看作0，棋盘问题把往右走看作1，往上走看作0，依然是0的个数在任意长度不能超过1的个数

类似的问题还有n个结点构造二叉树种类。也是用递归的方式，N种选根的办法

10个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问有多少种排列方式。把人从矮到高排，用等长的数列代表排法，0代表放在第1排，1代表第2排

n对括号正确匹配成的字符串数

n+1个数相乘，所有的括号方案数

n+2条边的多边形，能被分割成三角形的方案数，用递归的思想去想，连接一条边之后分成两个多边形，因为一条边有两个点，所以结果需要除2

## 平衡二叉树（AVL）

它是一种二叉排序树，是指一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树，常用红黑树来实现。F(n)=F(n-1)+F(n-2)+1 ，是在对一棵查找树能进行增删查的工作的时候仍然保持好身材，使得所花时间与logn成比例。

将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。 距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。

平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。常见的有LL，RR，LR，RL调整

## 红黑树

jdk1.8以后的hashmap是用红黑树来实现的，但我并不会java（逃）

红黑树是一种自平衡的二叉树，在插入和删除的过程中会采取一定的策略对树的组织形式进行调整，以尽可能减少树的高度来减少查找时间。特点是结点为红/黑，根节点始终是黑色，叶子（要挂上满的NIL）结点也是黑色，红色结点的两个直接孩子为黑，任意结点到每个叶子的所有简单路径都包含相同数量的黑色结点。这样可以保证在满足平衡二叉树的前提下，根到叶子结点的最长路径不会超过最短路径的两倍。平衡策略包括左旋，右旋，变色。这里和平衡二叉树不同的是它的旋转定义是按照作用结点来旋转的。

约定新插入的结点为红色，策略如下：

- 如果插入的是根结点，则变色
- 插入结点的父结点是黑色，如果是左侧插入则不用操作；右侧插入则左旋加变色
- 父结点为红色，叔结点也为红色，如果是左插入则变色后向上递归；右插入则左旋加变色
- 父结点为红色，叔结点为黑色或不存在，如果左插入则右旋加变色；右插入则左旋再右旋加变色

删除策略，执行前先判断删除结点有几个孩子结点，如果是两个的话我们需要从左子树上寻找值最大的，或右子树寻找值最小的，用结点值替换掉删除结点的值，替换成只有一个孩子结点的删除情况：

- 如果删除结点是黑色的，直接删去
- 如果是黑色的，但有一个红色孩子，那么就用孩子替换之后变色
- 如果是黑色的，他的孩子结点也是黑色的，还是先用孩子替换该结点，记作N，然后分类讨论
  - 如果N是新的根，那么没事了
  - 如果N的父结点P，兄弟结点B，B的孩子结点都是黑色时，将B变色，然后向上P递归
  - B为红色，其余结点均为黑色时，左旋加变色
  - P为红色，B和B的兄弟都为黑色，变色
  - B为黑色，B的左孩子红色，右孩子黑色，右旋加变色
  - B为黑色，B的右孩子为红色，左旋加变色

结论：在相同的节点情况下，AVL树的高度低于红黑树，但相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，红黑树更高效一些

## LFU缓存机制

需要创造一个链表节点类，节点需要包含前后节点信息，节点的频数信息，其key和val的信息。用一个keymap的字典来哈希存储key对应的节点信息。然后再构造一个freqMap的哈希表，对每个频数上都初始化一个有头尾节点的双向链表。在LFU类中还需要有保存此时size的变量，capacity的变量和此时最小频数的变量

## 约瑟夫环

N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者

很神奇的是，如果反推，只需要把杀死的那个人加在最后面，然后右移M位，把溢出的部分顺序放在最前面，就还原了之前的序列

编程的时候，可以用递归的思想去理解，最后一个人的下标一定为0

## atoi函数，自动机

DFA（有限状态机），关键是建立一个状态跳转的表格，根据上一个状态和当前字符来根据表格更新当前状态，一般建一个新的类来维护里面的变量，这样写出来的代码比较全面而且不会太臃肿

## 动态规划求解编辑距离

一看到题目就觉得应该是动态规划，困难题肯定不是一维，那么最自然的就是定义word1中的前i个子串和word2中的前j个子串为dp[i][j]

对于增删改三种操作，要意识到顺序是无所谓的

在有一个是空串的时候，边界上的距离就是另一个非空串的长度

在更新的时候判断当前末位置是否相等，然后注意下标和dp中下标的对应含义，很快就能写出代码来

## python输入输出常用的函数

sys.stdin.readline()不会把字符串末尾的/n去掉，所以一般后面会加上strip()函数，内参数是需要去除的东西，默认为空格，去两头。等效于input()，如果是整型之类的外面再强制转化一下就可以，如果字符串需要分割再转型，就用lines = line.split()割成列表，然后用lines = list(map(int, lines))

多行输入和需要循环读入的时候：可以while True然后try except

```python
try:
    while(True):
        row = int(input())
        lines_multrows = []
        for n in range(row):    
            line = input()
            if line=='': # (if not line 也可以)
                break
        lines = line.split()
        lines = list(map(int,lines))
        lines_multrows.append(lines) #多行数组
except:
      pass
```

join函数也挺常用的，"用什么连接".join(seq_list)。输出的时候如果需要换行则直接循环print()，如果单行输出则使用print(xx, end = " ")

%o八进制，%d十进制，%x十六进制

%.3f，3位小数，f表示浮点形式输出，默认六位

%e，科学计数法输出，默认六位

字符串输出%10.2s，占位10右对齐，-10就是左对齐，点2还是取几位的意思

更高阶的输出可以用format，"{} {}".format("","")，{}里可以带index或者关键字，还有很多新用法，不展开了

## 旋转矩阵

如果新开一个数组，找到角标之间的关系不难。如果要求原地，那么有两种方法，第一种推导的成分比较多一些，就是发现每4个循环又会回到原地，所以用一个tmp变量就可以把四个角换过来，再思考一下需要交换的元素循环起止位置（分奇偶的情况进行思考）。

还有一种比较难理解，但是很容易写，顺时针旋转90度就相当于先上下翻转，然后沿顺对角线翻转



