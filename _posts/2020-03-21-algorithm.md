---
layout: post
title: "Algorithm learning"
date: 2020-03-21 01:13:14
image: '/assets/img/'
description: 'Algorithm learning note'
tags:
- algorithm
categories:
- Backend
twitter_text: 'Do you know these?'

---

## Everyday sentence

11-29: I don't like rasins. They used to be fat and jucy, and now they are twisted. They had their lives stolen. They taste sweet, but really they are humiliated grapes.

12-1: We all fear death and question our place in the universe. The artist's job is not to succumb to despair, but to find an antidote for the emptiness of existence.

12-2: You know the only thing that has made the whole thing worthwhile...has been those... few times that I've been able to really, truly connect with another human being.

12-3: We are made of dreams, and dreams are made of us.

12-5: Funny, how just when you think life can't possibly get any worse it suddenly does.

12-6: 美丽的梭罗河/ 我为你歌唱 / 你的光荣历史 / 我永远记在心上 / 旱季来临 / 你轻轻流淌 / 雨季时波涛滚滚 / 你流向远方

## 快速排序和快速选择排序

都是基于分治的思想

快排一般是选左边的数low作为基准数，然后从表的最右边放一个哨兵开始向左搜索，找到第一个小于基准数的记录，并将其的值赋给low，然后从左侧开始向右搜索，找到第一个大于基准数的记录，把其值赋给right，然后再交替搜索，直到指针相遇，把基准数的值赋给这个指针的位置，这样就以pivot为标准完成了一次划分，依次对左右进行递归即可

后来我又看见了一种新的思路去做，该思路是随机选择一个主元，然后把它放在最右边。定义两个指针 i 和 j ，一开始 i = l - 1，j = l。每次移动 j , 如果 j 上的值比主元要大，就 j ++。否则 i +1 ， 交换 i 和 j。 j 移动到 r - 1的时候终止。交换 i + 1和 r 即可完成一次划分

在主sort函数里面把 r <= l 的情况return掉，然后根据partition得到mid，分别对左右两块进行递归

快速选择是为了找到第K大的数的一种更高效的算法，它可以不用保证主元左右两边有序，一次主元划分结束后比较k和主元的位置，有选择地对左边或者右边递归。一般分为select函数，和一个内部的partition函数。partition是一个用于找主元位置的函数，select用二分的思想并进行剪枝，只需要一半的计算量，另外在主元的选择上多了一步随机选择

## BFPRT算法

这是更高级的算法，通过n/mod 5，向下取整分组，每组中五个元素，每个组的中位数可以用插入排序得到。通常被分为partition函数，pivot_median函数，bfprt函数。思想是用组中中位数的中位数作为pivot来划分。经过数学证明在top k问题上有线性的复杂度

## 堆排序

构建大根堆，使得父元素的节点大于等于它的子节点。我们将堆顶最大的元素与末尾元素进行交换，通过调整堆顶元素使得剩下的n - 1个元素仍为大根堆，重复执行以上的操作就可以得到一个有序序列

## 归并排序

二分序列，对左右分别进行排序，然后最后线性归并，用两个指针分别指示两个序列中归并到哪一位了

## 待做的题目

最小窗口子序列，找迷宫中的最小路径

## 卡特兰数

2n个人围城一圈,两两握手,没有交叉，问有多少种方式：第一个人可以和偶数的人握手，h(n) 定义为2*n个人的方式次数，h(0) = 1, h(1) = 1, h(n) = h(0) * h(n -1) + .... h(n-1)*h(0)

C(n,2n)/(n+1)  = C(n,2n) - C(n+1,2n) = (4n-2)*h(n-1)/(n+1)

= (2n!) / (n! \* n!) / (n + 1)

一堆数入出栈序列的组合数，小兔的棋盘（从00到nn不越过对角线的走法），可以转换成序列任务。组合数把入栈看作1出栈看作0，棋盘问题把往右走看作1，往上走看作0，依然是0的个数在任意长度不能超过1的个数

类似的问题还有n个结点构造二叉树种类。也是用递归的方式，N种选根的办法

10个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问有多少种排列方式。把人从矮到高排，用等长的数列代表排法，0代表放在第1排，1代表第2排

n对括号正确匹配成的字符串数

n+1个数相乘，所有的括号方案数

n+2条边的多边形，能被分割成三角形的方案数，用递归的思想去想，连接一条边之后分成两个多边形，因为一条边有两个点，所以结果需要除2

## 平衡二叉树（AVL）

它是一种二叉排序树，是指一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树，常用红黑树来实现。F(n)=F(n-1)+F(n-2)+1 ，是在对一棵查找树能进行增删查的工作的时候仍然保持好身材，使得所花时间与logn成比例。

将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。 距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。

平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。常见的有LL，RR，LR，RL调整

## 红黑树

jdk1.8以后的hashmap是用红黑树来实现的，但我并不会java（逃）

红黑树是一种自平衡的二叉树，在插入和删除的过程中会采取一定的策略对树的组织形式进行调整，以尽可能减少树的高度来减少查找时间。特点是结点为红/黑，根节点始终是黑色，叶子（要挂上满的NIL）结点也是黑色，红色结点的两个直接孩子为黑，任意结点到每个叶子的所有简单路径都包含相同数量的黑色结点。这样可以保证在满足平衡二叉树的前提下，根到叶子结点的最长路径不会超过最短路径的两倍。平衡策略包括左旋，右旋，变色。这里和平衡二叉树不同的是它的旋转定义是按照作用结点来旋转的。

约定新插入的结点为红色，策略如下：

- 如果插入的是根结点，则变色
- 插入结点的父结点是黑色，如果是左侧插入则不用操作；右侧插入则左旋加变色
- 父结点为红色，叔结点也为红色，如果是左插入则变色后向上递归；右插入则左旋加变色
- 父结点为红色，叔结点为黑色或不存在，如果左插入则右旋加变色；右插入则左旋再右旋加变色

删除策略，执行前先判断删除结点有几个孩子结点，如果是两个的话我们需要从左子树上寻找值最大的，或右子树寻找值最小的，用结点值替换掉删除结点的值，替换成只有一个孩子结点的删除情况：

- 如果删除结点是黑色的，直接删去
- 如果是黑色的，但有一个红色孩子，那么就用孩子替换之后变色
- 如果是黑色的，他的孩子结点也是黑色的，还是先用孩子替换该结点，记作N，然后分类讨论
  - 如果N是新的根，那么没事了
  - 如果N的父结点P，兄弟结点B，B的孩子结点都是黑色时，将B变色，然后向上P递归
  - B为红色，其余结点均为黑色时，左旋加变色
  - P为红色，B和B的兄弟都为黑色，变色
  - B为黑色，B的左孩子红色，右孩子黑色，右旋加变色
  - B为黑色，B的右孩子为红色，左旋加变色

结论：在相同的节点情况下，AVL树的高度低于红黑树，但相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，红黑树更高效一些

## LFU缓存机制

需要创造一个链表节点类，节点需要包含前后节点信息，节点的频数信息，其key和val的信息。用一个keymap的字典来哈希存储key对应的节点信息。然后再构造一个freqMap的哈希表，对每个频数上都初始化一个有头尾节点的双向链表。在LFU类中还需要有保存此时size的变量，capacity的变量和此时最小频数的变量

## 约瑟夫环

N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者

很神奇的是，如果反推，只需要把杀死的那个人加在最后面，然后右移M位，把溢出的部分顺序放在最前面，就还原了之前的序列

编程的时候，可以用递归的思想去理解，最后一个人的下标一定为0

## atoi函数，自动机

DFA（有限状态机），关键是建立一个状态跳转的表格，根据上一个状态和当前字符来根据表格更新当前状态，一般建一个新的类来维护里面的变量，这样写出来的代码比较全面而且不会太臃肿

## 动态规划求解编辑距离

一看到题目就觉得应该是动态规划，困难题肯定不是一维，那么最自然的就是定义word1中的前i个子串和word2中的前j个子串为dp[i][j]

对于增删改三种操作，要意识到顺序是无所谓的

在有一个是空串的时候，边界上的距离就是另一个非空串的长度

在更新的时候判断当前末位置是否相等，然后注意下标和dp中下标的对应含义，很快就能写出代码来

## python输入输出常用的函数

sys.stdin.readline()不会把字符串末尾的/n去掉，所以一般后面会加上strip()函数，内参数是需要去除的东西，默认为空格，去两头。等效于input()，如果是整型之类的外面再强制转化一下就可以，如果字符串需要分割再转型，就用lines = line.split()割成列表，然后用lines = list(map(int, lines))

多行输入和需要循环读入的时候：可以while True然后try except

```python
try:
    while(True):
        row = int(input())
        lines_multrows = []
        for n in range(row):    
            line = input()
            if line=='': # (if not line 也可以)
                break
        lines = line.split()
        lines = list(map(int,lines))
        lines_multrows.append(lines) #多行数组
except:
      pass
```

join函数也挺常用的，"用什么连接".join(seq_list)。输出的时候如果需要换行则直接循环print()，如果单行输出则使用print(xx, end = " ")

%o八进制，%d十进制，%x十六进制

%.3f，3位小数，f表示浮点形式输出，默认六位

%e，科学计数法输出，默认六位

字符串输出%10.2s，占位10右对齐，-10就是左对齐，点2还是取几位的意思

更高阶的输出可以用format，"{} {}".format("","")，{}里可以带index或者关键字，还有很多新用法，不展开了

## 旋转矩阵

如果新开一个数组，找到角标之间的关系不难。如果要求原地，那么有两种方法，第一种推导的成分比较多一些，就是发现每4个循环又会回到原地，所以用一个tmp变量就可以把四个角换过来，再思考一下需要交换的元素循环起止位置（分奇偶的情况进行思考）。

还有一种比较难理解，但是很容易写，顺时针旋转90度就相当于先上下翻转，然后沿顺对角线翻转

## DFS和BFS

网格上的题目基本都是用遍历求解的，dfs可以用来计数，不满足条件的时候return 0，满足的时候return 1 + dfs。bfs是用一个队列非空的时候做一些操作。set可以用来装不重复的答案值，涉及坐标的时候可以打包成元组存储

## 递归问题

要善于发现问题中与原问题拥有相同子结构的子问题，递归中为了提高效率会进行回溯和减枝，本质就是DFS/BFS，更容易理解一点。也可以转化为动态规划的问题。

## 扔鸡蛋问题

很经典的大厂编程题，N表示有几层楼，K表示有几个鸡蛋，我们要找到鸡蛋恰好摔不碎的楼层所需要的最少移动次数。是具有相当难度的动态规划问题

```python
class Solution:
    def superEggDrop(self, K: int, N: int) -> int:
        memo = dict()
        def dp(K, N):
            # base case
            if K == 1:
                # 只有一个鸡蛋了，这时候只能扫完N层
                return N
            if N == 0:
                # 搜索区间为空，那这次递归不需要计次
                return 0
            res = float("inf")
            # 查一下是不是已经算过了
            if (K,N) in memo:
                return memo[(K,N)]
            for i in range(1,N+1):
                # 我们考虑最坏情况，所以应该选分类中较大的return
                res = min(res, max(dp(K-1,i-1),dp(K,N-i))+1)
            # 加到备忘录里
            memo[(K,N)] = res
            return res
        return dp(K,N)
```

如果在第i层扔了，鸡蛋碎了，那么在1到 i-1 层楼搜索，状态变为dp（K-1，i-1）。如果鸡蛋碎了，那么在 i+1层到N层， 到dp（K，N-i ）

为了提升效率，可以加上一个备忘录。

但尽管如此，时间复杂度还是很高，时间复杂度是KN*N。我们还可以进一步优化，把dp中的那个N循环用二分查找的方法搜索优化为logn。

进一步优化可以修改状态的定义，

```
dp[k][m] = n
# 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋
# 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼
# 转移方程，鸡蛋没碎测楼上层数，鸡蛋碎了测楼下层数，再加上当前层数
dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1
```

接着就是填表了，如果单纯正向填表的话也挺慢的，但是因为我们需要返回的是符合dp[K] [ j ]大于等于N的最小 j 。所以我们可以竖着填表，这样可以把时间复杂度降低为KN，速度实测提升接近十倍。

更加牛逼的，如果我们用一维数组去更新的话，我们会发现，每一个状态与他左边和左上的状态有关，所以我们实际上更快的是倒着填表。这样又能在前面的基础上再提升三倍。

最后的最后，更骚的还可以在m的搜索上用上二分查找，把时间复杂度进一步降低为K * logN

## 光影切割问题中的逆序数求解

在光影切割问题中除了直接去求解直线交点是否在区间内，还可以用一种很聪明的办法去看边界交点是否逆序来得到交点的数目。

## 寻找01矩阵中1离最近0的距离

首先，因为是在1上面的位置显示距离，而我们的搜索算法基本上是在终点位置返回，所以需要反着思考，把起点从0开始搜索

第一种想法是用BFS，0元素全部入队，用一个set来表示是否被访问过。第二种想法是用动态规划，因为两点之间的距离要最短只会包含两种状态（左上，左下，右上和右下），分别用动态规划的思想去填表，要注意填表的起点会随着方向的不同而变化（其实只需要左上和右下两次遍历就可以了）

## 一手顺子

输入：hand = [1,2,3,6,2,3,4,7,8], W = 3
输出：true
解释：手牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。

需要用到count函数，一种想法是用while循环，从最小的count开始不断在顺子上都减1，如果中途发现顺子断了就return False，如果能用完所有的count就return True

还有一种方法是把count之后的字典排序，然后遍历字典，在顺子循环中可以一次减去多张牌，如果此时键不存在返回false，如果此时的count是0就continue下一个count

## 简单顺子

给一串数字，判断是否为顺子，0表示大小王可以代替任何数字

有两种思路，首先这些牌里除了0不能有重复的数字，然后这里面最大的数字减去最小的数字（不考虑大小王）加1应该等于牌的数量

还有一种思路是进行排序，然后用大小王去填补中间有空缺的数列，看看大小王的数量是不是能填补这些空缺

## 扑克牌

一行是个空格分隔的整数A1,A2,…A10,分别代表牌为A,2,…,10的个数. 可以打单牌，对子，顺子，三对，输出打完所有牌的最少次数

## 统计重复个数（找循环节）

通过两层循环储存所有匹配终末位置，最后再数结尾标志符的个数

## 岛屿数量

挺经典的，刷了好几遍了，1是陆地0是水，输出岛屿的个数。有三种思路，BFS，DFS和并查集。遍历的思想是循环遍历每一个元素，如果是陆地就把岛屿数量加一并从它开始向四个方向探索，探索过之后就把这个位置当作海洋。

并查集的思想很容易理解，写法上用一个字典实现，对每一个unique的键值，存储它的父节点。主要分为两个函数，union(x,y)实现的是树的根合并。find(x)的作用是找到x元素的根结点，并且做一个压缩路径(相当于把根节点路径上的所有元素都直接连到根节点上，可以节省很多时间)，把字典里的父结点直接连到根节点上。这题里位置可以用index来指示。 ##  遍历的时候有个优化，可以只搜索一半的方向

