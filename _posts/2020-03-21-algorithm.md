---
layout: post
title: "Algorithm learning"
date: 2020-03-21 01:13:14
image: '/assets/img/'
description: 'Algorithm learning note'
tags:
- algorithm
categories:
- Backend
twitter_text: 'Do you know these?'

---

## Everyday sentence

11-29: I don't like rasins. They used to be fat and jucy, and now they are twisted. They had their lives stolen. They taste sweet, but really they are humiliated grapes.

12-1: We all fear death and question our place in the universe. The artist's job is not to succumb to despair, but to find an antidote for the emptiness of existence.

12-2: You know the only thing that has made the whole thing worthwhile...has been those... few times that I've been able to really, truly connect with another human being.

12-3: We are made of dreams, and dreams are made of us.

12-5: Funny, how just when you think life can't possibly get any worse it suddenly does.

12-6: 美丽的梭罗河/ 我为你歌唱 / 你的光荣历史 / 我永远记在心上 / 旱季来临 / 你轻轻流淌 / 雨季时波涛滚滚 / 你流向远方

## 快速排序和快速选择排序

都是基于分治的思想

快排一般是选左边的数low作为基准数，然后从表的最右边放一个哨兵开始向左搜索，找到第一个小于基准数的记录，并将其的值赋给low，然后从左侧开始向右搜索，找到第一个大于基准数的记录，把其值赋给right，然后再交替搜索，直到指针相遇，把基准数的值赋给这个指针的位置，这样就以pivot为标准完成了一次划分，依次对左右进行递归即可

后来我又看见了一种新的思路去做，该思路是随机选择一个主元，然后把它放在最右边。定义两个指针 i 和 j ，一开始 i = l - 1，j = l。每次移动 j , 如果 j 上的值比主元要大，就 j ++。否则 i +1 ， 交换 i 和 j。 j 移动到 r - 1的时候终止。交换 i + 1和 r 即可完成一次划分

在主sort函数里面把 r <= l 的情况return掉，然后根据partition得到mid，分别对左右两块进行递归

快速选择是为了找到第K大的数的一种更高效的算法，它可以不用保证主元左右两边有序，一次主元划分结束后比较k和主元的位置，有选择地对左边或者右边递归。一般分为select函数，和一个内部的partition函数。partition是一个用于找主元位置的函数，select用二分的思想并进行剪枝，只需要一半的计算量，另外在主元的选择上多了一步随机选择

## BFPRT算法

这是更高级的算法，通过n/mod 5，向下取整分组，每组中五个元素，每个组的中位数可以用插入排序得到。通常被分为partition函数，pivot_median函数，bfprt函数。思想是用组中中位数的中位数作为pivot来划分。经过数学证明在top k问题上有线性的复杂度

## 堆排序

构建大根堆，使得父元素的节点大于等于它的子节点。我们将堆顶最大的元素与末尾元素进行交换，通过调整堆顶元素使得剩下的n - 1个元素仍为大根堆，重复执行以上的操作就可以得到一个有序序列

## 归并排序

二分序列，对左右分别进行排序，然后最后线性归并，用两个指针分别指示两个序列中归并到哪一位了

## 待做的题目

最小窗口子序列，找迷宫中的最小路径

## 卡特兰数

2n个人围城一圈,两两握手,没有交叉，问有多少种方式：第一个人可以和偶数的人握手，h(n) 定义为2*n个人的方式次数，h(0) = 1, h(1) = 1, h(n) = h(0) * h(n -1) + .... h(n-1)*h(0)

C(n,2n)/(n+1)  = C(n,2n) - C(n+1,2n) = (4n-2)*h(n-1)/(n+1)

= (2n!) / (n! \* n!) / (n + 1)

一堆数入出栈序列的组合数，小兔的棋盘（从00到nn不越过对角线的走法），可以转换成序列任务。组合数把入栈看作1出栈看作0，棋盘问题把往右走看作1，往上走看作0，依然是0的个数在任意长度不能超过1的个数

类似的问题还有n个结点构造二叉树种类。也是用递归的方式，N种选根的办法

10个高矮不同的人，排成两排，每排必须是从矮到高排列，而且第二排比对应的第一排的人高，问有多少种排列方式。把人从矮到高排，用等长的数列代表排法，0代表放在第1排，1代表第2排

n对括号正确匹配成的字符串数

n+1个数相乘，所有的括号方案数

n+2条边的多边形，能被分割成三角形的方案数，用递归的思想去想，连接一条边之后分成两个多边形，因为一条边有两个点，所以结果需要除2

## 平衡二叉树（AVL）

它是一种二叉排序树，是指一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是平衡二叉树，常用红黑树来实现。F(n)=F(n-1)+F(n-2)+1 ，是在对一棵查找树能进行增删查的工作的时候仍然保持好身材，使得所花时间与logn成比例。

将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。 距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。

平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。常见的有LL，RR，LR，RL调整

## 红黑树

jdk1.8以后的hashmap是用红黑树来实现的，但我并不会java（逃）

红黑树是一种自平衡的二叉树，在插入和删除的过程中会采取一定的策略对树的组织形式进行调整，以尽可能减少树的高度来减少查找时间。特点是结点为红/黑，根节点始终是黑色，叶子（要挂上满的NIL）结点也是黑色，红色结点的两个直接孩子为黑，任意结点到每个叶子的所有简单路径都包含相同数量的黑色结点。这样可以保证在满足平衡二叉树的前提下，根到叶子结点的最长路径不会超过最短路径的两倍。平衡策略包括左旋，右旋，变色。这里和平衡二叉树不同的是它的旋转定义是按照作用结点来旋转的。

约定新插入的结点为红色，策略如下：

- 如果插入的是根结点，则变色
- 插入结点的父结点是黑色，如果是左侧插入则不用操作；右侧插入则左旋加变色
- 父结点为红色，叔结点也为红色，如果是左插入则变色后向上递归；右插入则左旋加变色
- 父结点为红色，叔结点为黑色或不存在，如果左插入则右旋加变色；右插入则左旋再右旋加变色

删除策略，执行前先判断删除结点有几个孩子结点，如果是两个的话我们需要从左子树上寻找值最大的，或右子树寻找值最小的，用结点值替换掉删除结点的值，替换成只有一个孩子结点的删除情况：

- 如果删除结点是黑色的，直接删去
- 如果是黑色的，但有一个红色孩子，那么就用孩子替换之后变色
- 如果是黑色的，他的孩子结点也是黑色的，还是先用孩子替换该结点，记作N，然后分类讨论
  - 如果N是新的根，那么没事了
  - 如果N的父结点P，兄弟结点B，B的孩子结点都是黑色时，将B变色，然后向上P递归
  - B为红色，其余结点均为黑色时，左旋加变色
  - P为红色，B和B的兄弟都为黑色，变色
  - B为黑色，B的左孩子红色，右孩子黑色，右旋加变色
  - B为黑色，B的右孩子为红色，左旋加变色

结论：在相同的节点情况下，AVL树的高度低于红黑树，但相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，红黑树更高效一些

## LFU缓存机制

需要创造一个链表节点类，节点需要包含前后节点信息，节点的频数信息，其key和val的信息。用一个keymap的字典来哈希存储key对应的节点信息。然后再构造一个freqMap的哈希表，对每个频数上都初始化一个有头尾节点的双向链表。在LFU类中还需要有保存此时size的变量，capacity的变量和此时最小频数的变量

## 约瑟夫环

N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者

很神奇的是，如果反推，只需要把杀死的那个人加在最后面，然后右移M位，把溢出的部分顺序放在最前面，就还原了之前的序列

编程的时候，可以用递归的思想去理解，最后一个人的下标一定为0

## atoi函数，自动机

DFA（有限状态机），关键是建立一个状态跳转的表格，根据上一个状态和当前字符来根据表格更新当前状态，一般建一个新的类来维护里面的变量，这样写出来的代码比较全面而且不会太臃肿

## 动态规划求解编辑距离

一看到题目就觉得应该是动态规划，困难题肯定不是一维，那么最自然的就是定义word1中的前i个子串和word2中的前j个子串为dp[i][j]

对于增删改三种操作，要意识到顺序是无所谓的

在有一个是空串的时候，边界上的距离就是另一个非空串的长度

在更新的时候判断当前末位置是否相等，然后注意下标和dp中下标的对应含义，很快就能写出代码来

## python输入输出常用的函数

sys.stdin.readline()不会把字符串末尾的/n去掉，所以一般后面会加上strip()函数，内参数是需要去除的东西，默认为空格，去两头。等效于input()，如果是整型之类的外面再强制转化一下就可以，如果字符串需要分割再转型，就用lines = line.split()割成列表，然后用lines = list(map(int, lines))

多行输入和需要循环读入的时候：可以while True然后try except

```python
try:
    while(True):
        row = int(input())
        lines_multrows = []
        for n in range(row):    
            line = input()
            if line=='': # (if not line 也可以)
                break
        lines = line.split()
        lines = list(map(int,lines))
        lines_multrows.append(lines) #多行数组
except:
      pass
```

join函数也挺常用的，"用什么连接".join(seq_list)。输出的时候如果需要换行则直接循环print()，如果单行输出则使用print(xx, end = " ")

%o八进制，%d十进制，%x十六进制

%.3f，3位小数，f表示浮点形式输出，默认六位

%e，科学计数法输出，默认六位

字符串输出%10.2s，占位10右对齐，-10就是左对齐，点2还是取几位的意思

更高阶的输出可以用format，"{} {}".format("","")，{}里可以带index或者关键字，还有很多新用法，不展开了

## 旋转矩阵

如果新开一个数组，找到角标之间的关系不难。如果要求原地，那么有两种方法，第一种推导的成分比较多一些，就是发现每4个循环又会回到原地，所以用一个tmp变量就可以把四个角换过来，再思考一下需要交换的元素循环起止位置（分奇偶的情况进行思考）。

还有一种比较难理解，但是很容易写，顺时针旋转90度就相当于先上下翻转，然后沿顺对角线翻转

## DFS和BFS

网格上的题目基本都是用遍历求解的，dfs可以用来计数，不满足条件的时候return 0，满足的时候return 1 + dfs。bfs是用一个队列非空的时候做一些操作。set可以用来装不重复的答案值，涉及坐标的时候可以打包成元组存储

## 递归问题

要善于发现问题中与原问题拥有相同子结构的子问题，递归中为了提高效率会进行回溯和减枝，本质就是DFS/BFS，更容易理解一点。也可以转化为动态规划的问题。

## 扔鸡蛋问题

很经典的大厂编程题，N表示有几层楼，K表示有几个鸡蛋，我们要找到鸡蛋恰好摔不碎的楼层所需要的最少移动次数。是具有相当难度的动态规划问题

```python
class Solution:
    def superEggDrop(self, K: int, N: int) -> int:
        memo = dict()
        def dp(K, N):
            # base case
            if K == 1:
                # 只有一个鸡蛋了，这时候只能扫完N层
                return N
            if N == 0:
                # 搜索区间为空，那这次递归不需要计次
                return 0
            res = float("inf")
            # 查一下是不是已经算过了
            if (K,N) in memo:
                return memo[(K,N)]
            for i in range(1,N+1):
                # 我们考虑最坏情况，所以应该选分类中较大的return
                res = min(res, max(dp(K-1,i-1),dp(K,N-i))+1)
            # 加到备忘录里
            memo[(K,N)] = res
            return res
        return dp(K,N)
```

如果在第i层扔了，鸡蛋碎了，那么在1到 i-1 层楼搜索，状态变为dp（K-1，i-1）。如果鸡蛋碎了，那么在 i+1层到N层， 到dp（K，N-i ）

为了提升效率，可以加上一个备忘录。

但尽管如此，时间复杂度还是很高，时间复杂度是KN*N。我们还可以进一步优化，把dp中的那个N循环用二分查找的方法搜索优化为logn。

进一步优化可以修改状态的定义，

```
dp[k][m] = n
# 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋
# 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼
# 转移方程，鸡蛋没碎测楼上层数，鸡蛋碎了测楼下层数，再加上当前层数
dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1
```

接着就是填表了，如果单纯正向填表的话也挺慢的，但是因为我们需要返回的是符合dp[K] [ j ]大于等于N的最小 j 。所以我们可以竖着填表，这样可以把时间复杂度降低为KN，速度实测提升接近十倍。

更加牛逼的，如果我们用一维数组去更新的话，我们会发现，每一个状态与他左边和左上的状态有关，所以我们实际上更快的是倒着填表。这样又能在前面的基础上再提升三倍。

最后的最后，更骚的还可以在m的搜索上用上二分查找，把时间复杂度进一步降低为K * logN



