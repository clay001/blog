---
layout: post
title: "OS learning"
date: 2020-02-29 01:05:14
image: '/assets/img/'
description: 'OS learning note'
tags:
- OS
categories:
- Backend
twitter_text: 'Do you know these?'
---

## Everyday sentence

11-29: I don't like rasins. They used to be fat and jucy, and now they are twisted. They had their lives stolen. They taste sweet, but really they are humiliated grapes.

12-1: We all fear death and question our place in the universe. The artist's job is not to succumb to despair, but to find an antidote for the emptiness of existence.

12-2: You know the only thing that has made the whole thing worthwhile...has been those... few times that I've been able to really, truly connect with another human being.

12-3: We are made of dreams, and dreams are made of us.

12-5: Funny, how just when you think life can't possibly get any worse it suddenly does.

12-6: 美丽的梭罗河/ 我为你歌唱 / 你的光荣历史 / 我永远记在心上 / 旱季来临 / 你轻轻流淌 / 雨季时波涛滚滚 / 你流向远方

## 进程

操作系统最核心的概念就是进程，它是对正在运行中的程序的一个抽象。在许许多多道程序系统中，CPU会在进程之间快速切换，使每个程序运行几十或者几百毫秒，在某一个瞬间，CPU只能运行一个进程（伪并行）。

只有多处理器的情况下才能实现真正的并行，但每个核也只能一次运行一个进程。在进程模型中，所以计算机上运行的软件，包括操作系统，都被组织味若干顺序进程（sequential process）。

进程就是一个正在执行的程序的实例，包括程序计数器，寄存器和变量的当前值。

进程的创建：

- 系统初始化：创建前台进程和守护进程
- 系统调用创建：创建一个或者多个新进程来帮助其完成工作。unix中是fork操作，该操作使得父进程和子进程拥有相同的内存映像，相同的环境字符串和相同的打开文件。通常，子进程会执行execve来改变内存映像并运行一个新程序。windows中win32功能调用CreateProcess。（可写的内存是不能被共享的，父子进程的地址空间是不同的）
- 用户请求创建：交互系统创建
- 批处理创建

进程的终止：正常退出，错误退出，严重错误或者被其他进程杀死

## fork函数

把某个进程下的资源全部复制一遍，给父进程返回其子进程的pid，给子进程返回0

## 进程体系

unix的进程之间有进程树一样的层级结构

windows没有层次的概念，唯一类似于层次结构的是在创建进程的时候，父进程会得到一个句柄，该句柄可以用来控制子进程。然而，这个令牌可能会移交给别的操作系统。

## 进程状态

进行态，就绪态，阻塞态

比如命令行cat chapter1 chapter2 chapter3 \| grep tree。第一个进程是cat，将三个文件级联并输出，第二个进程是grep，它从输入中选择具有包含关键字tree的内容。

## 进程的实现

为了执行进程间的切换，会维护着一张表格，这张表就是进程表。每个进程占用一个进程表项，包括程序计数器，堆栈指针，内存分配状况，所打开文件的状态，账号和调度信息，以及其他在进程状态转换的信息。（总的来说就包含进程管理，存储管理和文件管理的表）

与每一个I/O类相关联的是一个称作中断向量的位置，在程序中断的时候，硬件作出保存反应，然后调用一个C程序来处理剩下的工作并调用调度程序运行其他进程，将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行。

## 线程

在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。但许多情况下，存在同一地址空间中运行多个控制线程的情形。这些线程就像是分离的进程。

多线程之间会共享同一块地址空间和所有可用数据的能力。这是进程所不具备的。线程也更轻量级。而且当存在大量的计算和I/O处理的时候，拥有多个线程能在这些活动中彼此重叠运行，加快应用程序的执行速度。

## 高速缓存

客户端发送请求给服务器，如果服务器有web页面高速缓存，就可以把大量访问的页面保存在内存中，而避免到磁盘中去调入这些页面。

## 线程和进程的区别

进程是资源分配的最小单位，线程是CPU调度（程序执行）的最小单位。线程是进程的实体。

进程可以类比成火车，线程可以类比成车厢去理解很多现象。

进程有自己独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护。线程是共享进程中的数据的，使用相同的地址空间，线程之间的通信也更方便，但要处理好同步与互斥的关系。

但是多线程程序中只要有一个线程死掉，整个进程也会死掉。

进程是在一定的环境下，把静态的程序代码运行起来，通过使用不同的资源，来完成一定的任务。线程作为进程的一部分，扮演的角色就是怎么利用中央处理器去运行代码。这其中牵扯到的最重要资源的是中央处理器和其中的寄存器，和线程的栈（stack）。强调的是，线程关注的是中央处理器的运行，而不是内存等资源的管理。

当只有一个中央处理器的时候，进程中只需要一个线程就够了。随着多处理器的发展，一个进程中可以有多个线程，来并行的完成任务。比如说，一个web服务器，在接受一个新的请求的时候，可以大动干戈的fork一个子进程去处理这个请求，也可以只在进程内部创建一个新的线程来处理。线程更加轻便一点。线程可以有很多，但他们并不会改变进程对内存（heap）等资源的管理，线程之间会共享这些资源。

## 僵尸进程

一个进程使用fork创建子进程，如果子进程退出，而父进程没有调用wait或者waitpid获取子进程的状态信息，那么子进程的进程描述符等一系列信息还保存在系统中的情况。ps命令运行的时候，状态栏为defunct，由于进程表的容量是有限的，所以僵尸进程不仅占用系统的内存资源，影响系统的性能，如果实在太多的时候会瘫痪系统。

## 孤儿进程

还是前面fork了子进程的状态，如果此时把父进程杀死，但是子进程还在运行的情况。它会被init进程收养。

## 线程同步的方式有哪些

互斥量、读写锁、自旋锁、线程信号、条件变量

互斥锁：线程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存，保证公共资源不会被多个线程同时访问

信号量：进程使用的内存地址可以限定使用量，控制同时时刻访问此资源的最大线程数量

事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便地实现多线程优先级的比较操作

## 进程同步有哪几种机制

进程同步是一种目的，为了控制多个进程按照一定顺序执行。为了达到这个目的，需要进程通信，

无名管道、有名管道、信号、共享内存、消息队列、信号量

管道：

- 普通管道PIPE：半双工通信，单向流动，一般是亲缘父子进程间流动
- 流管道（s_pipe）
- 命名管道FIFO（name_pipe）：半双工，允许无亲缘通信

系统IPC（消息队列，信号量，共享存储）：

- 信号量是一个计数器，用来控制多个进程对资源的访问，是一种锁机制
- 消息队列是消息的链表，存放在内核中由消息队列标识符号
- 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
- 共享内存是最快的IPC（进程间通信）方式

Socket（套接字）：用于不同机器之间的通信

## 什么是缓冲区溢出，有什么危害

是指当计算机向缓冲区填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

这样程序会崩溃，或者跳转并执行一段恶意代码

一般是由于程序没有仔细检查用户输入造成的

## 什么是死锁，死锁产生的条件

在两个或者多个并发系统中，如果每个进程持有某种资源，而又等待其他进程释放它或他们现在保持着的资源，在未改变这种状态之前都不能向前推进，则称这一组进程产生了死锁。（两个或者多个进程无限期的阻塞，相互等待的一种状态）

死锁产生的四个条件：

- 互斥条件（一个资源只能被一个进程使用）
- 请求与保持条件（一个进程因请求资源而阻塞的时候对已获得资源保持不放）
- 不剥夺条件（进程获得的资源，在未完全使用完之前，不能强行剥夺）
- 循环等待条件（若干进程之间形成一种头尾相接的环形等待资源关系）

## 死锁的处理基本策略和常用方法

预防死锁（破坏条件，但以性能为损失）

避免死锁（银行家算法，允许进程动态申请资源）

检测死锁（为资源和进程指定唯一的号码，建表）

解死锁（剥夺资源，撤销进程策略）

## 进程有哪几种状态

就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源

运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数

阻塞状态：进程等待某种条件，在满足之前无法执行

## 分段和分页有什么区别

段是信息的逻辑单位，它是根据用户的需要划分的，用于存储保护和信息的共享，因此段是对用户可见的

页是信息的物理单位，是为了管理主存的方便而使用的，页的保护和共享受到限制，但对用户是透明的

段的大小不固定，由它所完成的功能决定；页的大小固定，由系统决定

段向用户提供二维地址空间，页向用户提供的是一维地址空间

## 操作系统中进程调度策略有哪几种

批处理系统：FCFS(先来先服务)，短作业优先

交互式系统：优先级调度（抢占式和非抢占式）（高响应比优先）

时间片轮转（雨露均沾），多级反馈队列（多个优先级的队列拥有不同的时间片，片内FCFS，并且实行抢占式）

## 并发和并行

并发是一段时间内同时运行多个程序，并行是同一时刻运行多个指令。操作系统通过引入线程和进程，使得程序能够并发运行。并行需要硬件支持，如多流水线，多核处理器和分布式计算系统

## 共享

系统中的资源可以被多个并发进程共同使用，分为互斥共享和同时共享

## 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体

分为时分复用技术和空分复用技术，多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一个小时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间，地址空间的页被映射到物理内存，地址空间的页不需要全部在物理内存中，当使用到一个没有物理内存的页时，执行页面置换方法，将该页置换到内存中

## 异步

进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进

## 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用进入内核，由操作系统代为完成

大内核是将操作系统功能作为一个紧密结合的整体放到内核，微内核是将一部分操作系统功能移出内核，移出的部分根据分层原则划分若干服务，相互独立，操作系统被划分成小的，定义良好的模块

## 中断类型

外中断是由CPU执行指令以外的事件。如I/O完成中断，时钟中断，控制台中断

异常是由CPU执行指令的内部时间引起。如非法操作码，地址越界，算术溢出

陷入是由用户程序中的系统调用引起的

## 生产者消费者问题

用一个缓存区来保存物品，只有缓冲区没满的时候，生产者才可以放入物品；缓冲区不为空的时候，消费者才可以拿走物品。

用互斥量来控制对缓冲区的互斥访问，用信号量统计缓冲区的物品数量

所谓管程，是把控制的代码独立出来的写法

## 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写，写和写同时发生

用一个整型变量count记录进程数量，用互斥量对count加锁，另一个互斥量对读写的数据加锁

## 哲学家进餐问题

一张圆桌五个哲学家，每个哲学家可以吃饭和思考，当一个哲学家吃饭的时候，需要拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子

为了防止死锁的发生，可以设置必须同时拿起左右两根筷子，只有在两个邻居都没有进餐的情况下才允许进餐

## 内存管理机制: 分页

分页表保存虚拟页和物理地址的关系

