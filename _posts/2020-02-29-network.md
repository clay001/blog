---
layout: post
title: "Network learning"
date: 2020-02-29 01:05:14
image: '/assets/img/'
description: 'Web network learning note'
tags:
- Web
categories:
- Backend
twitter_text: 'Do you know these?'
---

## Everyday sentence

11-29: I don't like rasins. They used to be fat and jucy, and now they are twisted. They had their lives stolen. They taste sweet, but really they are humiliated grapes.

12-1: We all fear death and question our place in the universe. The artist's job is not to succumb to despair, but to find an antidote for the emptiness of existence.

12-2: You know the only thing that has made the whole thing worthwhile...has been those... few times that I've been able to really, truly connect with another human being.

12-3: We are made of dreams, and dreams are made of us.

12-5: Funny, how just when you think life can't possibly get any worse it suddenly does.

12-6: 美丽的梭罗河/ 我为你歌唱 / 你的光荣历史 / 我永远记在心上 / 旱季来临 / 你轻轻流淌 / 雨季时波涛滚滚 / 你流向远方

## 层级定义

OSI七层协议，TCP/IP四层协议，现在一般用融合二者的五层协议

应用层（DNS，HTTP，SMTP协议）

运输层（TCP，UDP）

网络层（IP协议）

链路层（链路层数据传输的协议，可靠传输性协议还可以纠错）

物理层（相邻计算机节点之间比特流的透明传送）

TCP协议未了保证可靠传输，拥有对数据进行最适切分和编号排序的功能，会进行校验和，丢弃重复数据，流量控制（滑动窗口协议），拥塞控制（维持一个拥塞窗口cwnd，TCP有慢开始「成倍增加窗口大小」，拥塞避免「每次加1」，快重传和快恢复「FRR，收到一个不安顺序的数据块的时候发送一个重复确认，发送机接受到三个重复确认的时候，会立即重传丢失了的数据段」算法，网络层油主动队列管理AQM的路由分组丢弃策略），停止等待协议（超时自动重传协议，连续ARQ协议）

## 长连接和短连接

HTTP的长连接和短连接，实质上是TCP协议的长连接和短连接

HTTP/1.0中默认使用短连接，也就是每次客户端和服务器进行一次HTTP操作就建立一次连接，任务结束就中断连接。

HTTP/1.1起就默认使用长连接，在响应头加入：Connection:keep-alive，这个保持连接的时间可以在不同的服务器软件（如Apache）中设定。

## 在浏览器输入url回车之后都发生了什么

*先url解析*

如果我们在地址栏输入taobao.com，浏览器走的是http的默认80端口，到达服务器后，告诉浏览器302跳转//taobao，浏览器再重新通过https请求443端口。这时候就容易出现中间人劫持的情况

HTST是强制客户端使用HTTPS访问页面的技术，可以避免中间人对80端口的劫持，但是如果用户在劫持状态，且没有访问过源服务器，那么还是无法被种下响应头。

*然后检查缓存*

DNS查询：浏览器缓存->操作系统缓存->路由器缓存->ISP DNS缓存->根域名服务器（浏览器到本地DNS的过程是递归方式查询，本地DNS到根域名服务器用的是迭代的方式查询）

DNS劫持：中文是域名解析服务的劫持，指通过某些手段取得某域名的解析记录控制权，今儿修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的IP。是通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。

DNS污染：中文是域名服务器缓存污染，指的是刻意制造或无意中制造出来的域名服务器分组，会快速地把域名指向一个不正确的IP地址，DNS一般走的是UDP协议

DNS prefetch：DNS预获取，是前端优化的一部分，让具有此属性的域名不需要用户点击链接就在后台进行解析，而域名解析和内容载入是串行的网络操作，所以这个方式可以减少用户的等待时间，提升用户体验

*TCP连接*

TCP/IP: 发送端应用层产生HTTP数据（请求报头和请求主体），传输层包上TCP首部，网络层再加上IP首部，链路层再加上以太网首部，然后一层层往上走去掉首部到达接受端

TCP建立连接需要进行*三次握手*：服务器分配并初始化变量和缓冲区以响应收到的SYN（假设seq为1000），然后发送一个SYN/ACK作为响应（seq为函数生成的2000，ack的值为1000 + xx）。然后等待一个来自客户端的ACK报文段（seq等于收到的ack值1001，ack的值为上一段的seq2000+xx），如果（1分钟左右）没有等到，服务器会终止这个半开的连接并回收资源

SYN泛洪攻击：拒绝服务攻击（DoS），攻击者发送大量的TCP/SYN报文段，但不继续进行握手。服务器的连接资源在分配给半开连接时会耗尽，然后合法的用户就被拒绝了。

SYN cookie：是一种有效的防御机制。在收到SYN之后不立即分配资源，而是创建初始TCP序列号，该序列号是由一个复杂的散列函数将源和目标的IP地址和SYN报文段中的端口号，以及只有该服务器知道的secret number作为输入得到的。然后服务器向客户端发送带有这个特殊序列号的SYN/ACK报文段，但并不用记住这个cookie。如果客户端是合法的，那么接下来会收到一个ACK，确认ACK中的值等于再用包头运行出来的seq+xx，那么就会创建一个完全打开的连接

TCP*四次挥手*：客户端发送一个FIN+ACK（假设seq值为2000，ack值为1000），服务端收到后发送一个ACK（seq为收到的ack值1000，ack为2001），服务端关闭连接后再发送一个FIN给客户端，客户端发回ACK报文确认（值为seq+1）

*查询MAC地址*

然后到网络层，将数据段打包，运用IP协议加入源和目标的ip地址，并且负责寻找传输路线，判断目标地址是否与当前地址处于同一网络中，是的话直接根据MAC地址发送，否则使用路由表查找下一地址，以及使用ARP协议查询它的MAC地址，实现路由器到服务器的通信

*以太网协助*

链路层根据以太网协议将数据分为以帧为单位的数据包（标头和数据）

MAC地址：以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡到另一块网卡，网卡的地址就是MAC地址

发送数据的时候通过ARP协议向本网络所有机器广播，然后接收方看MAC地址是否匹配，匹配就接收，不匹配就丢弃

ARP（address resolution protocal）: 在本层和硬件接口层进行联系，同时对上层的网络层提供服务。是用于确定MAC地址和IP地址的对应关系的。局域网的一台主机，如果接到了一个ARP报文，即使该报文不是该主机发送的ARP请求的应答报文，该主机也会将ARP报文中的发送者的MAC地址和IP地址更新或者加入到ARP表中

ARP攻击：通过使得ARP表不正确来冒充网关或者冒充主机

*服务器处理请求*

HTPPD：常见的有Linux上常用的Apache和Ngnix，Windows上的IIS等。它会监听得到的请求，然后开启一个子进程去处理这个请求，对HTTP协议进行解析验证

重定向：如果服务器配置了HTTP重定向，就会返回一个301永久重定向响应，浏览器会根据这个响应，重新发送HTTP请求

URL重写：如果请求的文件是真实存在的，则会直接把这个文件返回，否则服务器会按照规则把请求重写到一个REST风格的URL上。然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。

*浏览器接受响应*

对资源进行分析，解压，缓存，根据不同的媒体类型进行解析

## 渲染页面

*HTML解析*

从上往下一行一行解析，先把二进制字节数据根据文件制定编码转换成字符串（HTML代码），然后预解析提前加载资源。

将输入解析成符号，同时构建树，比如解析到一个开始标识，就创建一个DOM节点。浏览器有容错机制。如果浏览器下载了CSS，它还会根据语法规范解析出所有的CSS并进行标识化，得到一个规则表。

DOM树和CSS规则表进行合并，计算尺寸，级联，渲染阻塞，回流，重绘，JavaScript 的编译执行等等。

## Javascript,css和html什么关系

html是用来标记内容的（重在组织）

css是用来修饰内容样式的（重在美化）

JS是一种脚本语言，解释器是JS引擎，用于拓展文档的交互能力（重在特效，弹窗，提交等交互行为）

## HTTP和HTTPS的区别

后者更安全

## TCP、UDP协议的区别

UDP

1. UDP 是无连接的；
2. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
3. UDP 是面向报文的；
4. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；
5. UDP 支持一对一、一对多、多对一和多对多的交互通信；
6. UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

TCP

1. TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
2. 每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；
3. TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；
4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；
5. 面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

## 常见状态码

Informational（请求正在处理）

Success（请求正常处理完毕）

Redirection（需要进行附加操作以完成请求）

Client Error（服务器无法处理请求）

Server Error（服务器处理请求出错）

